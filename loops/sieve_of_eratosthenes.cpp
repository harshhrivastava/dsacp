#include <iostream>
#include <malloc.h>

using namespace std;

bool* sieveOfEratosthenes(int limit) {

    // This dynamically created array will store the results. 
    bool* isPrime = new bool[limit];
    
    // Setting all the elements of the array to true.
    for(int i = 1; i <= limit; i++) isPrime[i - 1] = true;
    
    // The first element, i.e., 1 will be false by default.
    // This is because 1 is neither a prime number, nor a composite number.
    isPrime[0] = false;
    
    // Here we start a loop starting from 1 till the specified limit.
    for(int i = 1; i <= limit; i++) {

        // We check whether the value of the element is true or not.
        // If it will be true, we will be settting all the multiples of this value as false.
        // Here we use `i - 1` because the starting value of array is 0,
        // and we started from 1. So we need to reduce 1 from the value of i.
        if (isPrime[i - 1]) {

            // Here we start the loop from the second multiple
            // till the last multiple, which is under the specified limit.
            for(int j = i * 2; j <= limit; j += i) {

                // If the multiple is true, we set it to false.
                if (isPrime[j - 1]) isPrime[j - 1] = false;
            }
        }
    }
    
    return isPrime;
}

int main(int argc, char const *argv[])
{
    // Here we convert the first argument
    // from a string into a number.
    int limit = stoi(argv[1]);
    
    // This boolean pointer points to the dynamically created array
    // which contains the result generated by the `sieveOfEratosthenes` function. 
    bool* isPrime = sieveOfEratosthenes(limit);
    
    // Once we receive the result, we iterate through the entire array
    // to get all those elements which are true and print the value of `i` for that iteration.
    for(int i = 1; i <= limit; i++) {

        // Here we check whether the value of the element is true or not.
        if (isPrime[i - 1]) {

            // If the value is true, we print the value of `i`.
            cout<<i<<endl;
        }
    }

    // We use this method over here to free up
    // the memory which was dynamically allocated.
    free(isPrime);
    
    return 0;
}
